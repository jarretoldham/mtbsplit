/**
 * Strava API v3
 * The [Swagger Playground](https://developers.strava.com/playground) is the easiest way to familiarize yourself with the Strava API by submitting HTTP requests and observing the responses before you write any client code. It will show what a response will look like with different endpoints depending on the authorization scope you receive from your athletes. To use the Playground, go to https://www.strava.com/settings/api and change your “Authorization Callback Domain” to developers.strava.com. Please note, we only support Swagger 2.0. There is a known issue where you can only select one scope at a time. For more information, please check the section “client code” at https://developers.strava.com/docs.
 *
 * OpenAPI spec version: 3.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as localVarRequest from 'request';
import Promise from 'bluebird';
import * as http from 'http';
import { Buffer } from 'buffer';

const DEFAULT_BASE_PATH = 'https://www.strava.com/api/v3';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
const PRIMITIVES = [
  'string',
  'boolean',
  'double',
  'integer',
  'long',
  'float',
  'number',
  'any',
];

class ObjectSerializer {
  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (PRIMITIVES.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === 'Date') {
      return expectedType;
    } else {
      if (enumsMap[expectedType]) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          return data[discriminatorProperty]; // use the type given in the discriminator
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string) {
    if (data == undefined) {
      return data;
    } else if (PRIMITIVES.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf('Array<', 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace('Array<', ''); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.serialize(date, subType));
      }
      return transformedData;
    } else if (type === 'Date') {
      return data.toString();
    } else {
      if (enumsMap[type]) {
        return data;
      }
      if (!typeMap[type]) {
        // in case we dont know the type
        return data;
      }

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance: { [index: string]: any } = {};
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.baseName] = ObjectSerializer.serialize(
          data[attributeType.name],
          attributeType.type,
        );
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (PRIMITIVES.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf('Array<', 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace('Array<', ''); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.deserialize(date, subType));
      }
      return transformedData;
    } else if (type === 'Date') {
      return new Date(data);
    } else {
      if (enumsMap[type]) {
        // is Enum
        return data;
      }

      if (!typeMap[type]) {
        // dont know the type
        return data;
      }
      let instance = new typeMap[type]();
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.name] = ObjectSerializer.deserialize(
          data[attributeType.baseName],
          attributeType.type,
        );
      }
      return instance;
    }
  }
}

/**
 * A set of rolled-up statistics and totals for an athlete
 */
export class ActivityStats {
  /**
   * The longest distance ridden by the athlete.
   */
  'biggestRideDistance'?: number;
  /**
   * The highest climb ridden by the athlete.
   */
  'biggestClimbElevationGain'?: number;
  /**
   * The recent (last 4 weeks) ride stats for the athlete.
   */
  'recentRideTotals'?: ActivityTotal;
  /**
   * The recent (last 4 weeks) run stats for the athlete.
   */
  'recentRunTotals'?: ActivityTotal;
  /**
   * The recent (last 4 weeks) swim stats for the athlete.
   */
  'recentSwimTotals'?: ActivityTotal;
  /**
   * The year to date ride stats for the athlete.
   */
  'ytdRideTotals'?: ActivityTotal;
  /**
   * The year to date run stats for the athlete.
   */
  'ytdRunTotals'?: ActivityTotal;
  /**
   * The year to date swim stats for the athlete.
   */
  'ytdSwimTotals'?: ActivityTotal;
  /**
   * The all time ride stats for the athlete.
   */
  'allRideTotals'?: ActivityTotal;
  /**
   * The all time run stats for the athlete.
   */
  'allRunTotals'?: ActivityTotal;
  /**
   * The all time swim stats for the athlete.
   */
  'allSwimTotals'?: ActivityTotal;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'biggestRideDistance',
      baseName: 'biggest_ride_distance',
      type: 'number',
    },
    {
      name: 'biggestClimbElevationGain',
      baseName: 'biggest_climb_elevation_gain',
      type: 'number',
    },
    {
      name: 'recentRideTotals',
      baseName: 'recent_ride_totals',
      type: 'ActivityTotal',
    },
    {
      name: 'recentRunTotals',
      baseName: 'recent_run_totals',
      type: 'ActivityTotal',
    },
    {
      name: 'recentSwimTotals',
      baseName: 'recent_swim_totals',
      type: 'ActivityTotal',
    },
    {
      name: 'ytdRideTotals',
      baseName: 'ytd_ride_totals',
      type: 'ActivityTotal',
    },
    {
      name: 'ytdRunTotals',
      baseName: 'ytd_run_totals',
      type: 'ActivityTotal',
    },
    {
      name: 'ytdSwimTotals',
      baseName: 'ytd_swim_totals',
      type: 'ActivityTotal',
    },
    {
      name: 'allRideTotals',
      baseName: 'all_ride_totals',
      type: 'ActivityTotal',
    },
    {
      name: 'allRunTotals',
      baseName: 'all_run_totals',
      type: 'ActivityTotal',
    },
    {
      name: 'allSwimTotals',
      baseName: 'all_swim_totals',
      type: 'ActivityTotal',
    },
  ];

  static getAttributeTypeMap() {
    return ActivityStats.attributeTypeMap;
  }
}

/**
 * A roll-up of metrics pertaining to a set of activities. Values are in seconds and meters.
 */
export class ActivityTotal {
  /**
   * The number of activities considered in this total.
   */
  'count'?: number;
  /**
   * The total distance covered by the considered activities.
   */
  'distance'?: number;
  /**
   * The total moving time of the considered activities.
   */
  'movingTime'?: number;
  /**
   * The total elapsed time of the considered activities.
   */
  'elapsedTime'?: number;
  /**
   * The total elevation gain of the considered activities.
   */
  'elevationGain'?: number;
  /**
   * The total number of achievements of the considered activities.
   */
  'achievementCount'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'count',
      baseName: 'count',
      type: 'number',
    },
    {
      name: 'distance',
      baseName: 'distance',
      type: 'number',
    },
    {
      name: 'movingTime',
      baseName: 'moving_time',
      type: 'number',
    },
    {
      name: 'elapsedTime',
      baseName: 'elapsed_time',
      type: 'number',
    },
    {
      name: 'elevationGain',
      baseName: 'elevation_gain',
      type: 'number',
    },
    {
      name: 'achievementCount',
      baseName: 'achievement_count',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return ActivityTotal.attributeTypeMap;
  }
}

/**
 * An enumeration of the types an activity may have. Note that this enumeration does not include new sport types (e.g. MountainBikeRide, EMountainBikeRide), activities with these sport types will have the corresponding activity type (e.g. Ride for MountainBikeRide, EBikeRide for EMountainBikeRide)
 */
export class ActivityType {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return ActivityType.attributeTypeMap;
  }
}

export class ActivityZone {
  'score'?: number;
  'distributionBuckets'?: TimedZoneDistribution;
  'type'?: ActivityZone.TypeEnum;
  'sensorBased'?: boolean;
  'points'?: number;
  'customZones'?: boolean;
  'max'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'score',
      baseName: 'score',
      type: 'number',
    },
    {
      name: 'distributionBuckets',
      baseName: 'distribution_buckets',
      type: 'TimedZoneDistribution',
    },
    {
      name: 'type',
      baseName: 'type',
      type: 'ActivityZone.TypeEnum',
    },
    {
      name: 'sensorBased',
      baseName: 'sensor_based',
      type: 'boolean',
    },
    {
      name: 'points',
      baseName: 'points',
      type: 'number',
    },
    {
      name: 'customZones',
      baseName: 'custom_zones',
      type: 'boolean',
    },
    {
      name: 'max',
      baseName: 'max',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return ActivityZone.attributeTypeMap;
  }
}

export namespace ActivityZone {
  export enum TypeEnum {
    Heartrate = <any>'heartrate',
    Power = <any>'power',
  }
}

export class BaseStream {
  /**
   * The number of data points in this stream
   */
  'originalSize'?: number;
  /**
   * The level of detail (sampling) in which this stream was returned
   */
  'resolution'?: BaseStream.ResolutionEnum;
  /**
   * The base series used in the case the stream was downsampled
   */
  'seriesType'?: BaseStream.SeriesTypeEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'originalSize',
      baseName: 'original_size',
      type: 'number',
    },
    {
      name: 'resolution',
      baseName: 'resolution',
      type: 'BaseStream.ResolutionEnum',
    },
    {
      name: 'seriesType',
      baseName: 'series_type',
      type: 'BaseStream.SeriesTypeEnum',
    },
  ];

  static getAttributeTypeMap() {
    return BaseStream.attributeTypeMap;
  }
}

export namespace BaseStream {
  export enum ResolutionEnum {
    Low = <any>'low',
    Medium = <any>'medium',
    High = <any>'high',
  }
  export enum SeriesTypeEnum {
    Distance = <any>'distance',
    Time = <any>'time',
  }
}

export class AltitudeStream extends BaseStream {
  /**
   * The sequence of altitude values for this stream, in meters
   */
  'data'?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'data',
      baseName: 'data',
      type: 'Array<number>',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(AltitudeStream.attributeTypeMap);
  }
}

export namespace AltitudeStream {}

export class CadenceStream extends BaseStream {
  /**
   * The sequence of cadence values for this stream, in rotations per minute
   */
  'data'?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'data',
      baseName: 'data',
      type: 'Array<number>',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(CadenceStream.attributeTypeMap);
  }
}

export namespace CadenceStream {}

export class MetaAthlete {
  /**
   * The unique identifier of the athlete
   */
  'id'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return MetaAthlete.attributeTypeMap;
  }
}

export class ClubActivity {
  'athlete'?: MetaAthlete;
  /**
   * The name of the activity
   */
  'name'?: string;
  /**
   * The activity's distance, in meters
   */
  'distance'?: number;
  /**
   * The activity's moving time, in seconds
   */
  'movingTime'?: number;
  /**
   * The activity's elapsed time, in seconds
   */
  'elapsedTime'?: number;
  /**
   * The activity's total elevation gain.
   */
  'totalElevationGain'?: number;
  /**
   * Deprecated. Prefer to use sport_type
   */
  'type'?: ActivityType;
  'sportType'?: SportType;
  /**
   * The activity's workout type
   */
  'workoutType'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'athlete',
      baseName: 'athlete',
      type: 'MetaAthlete',
    },
    {
      name: 'name',
      baseName: 'name',
      type: 'string',
    },
    {
      name: 'distance',
      baseName: 'distance',
      type: 'number',
    },
    {
      name: 'movingTime',
      baseName: 'moving_time',
      type: 'number',
    },
    {
      name: 'elapsedTime',
      baseName: 'elapsed_time',
      type: 'number',
    },
    {
      name: 'totalElevationGain',
      baseName: 'total_elevation_gain',
      type: 'number',
    },
    {
      name: 'type',
      baseName: 'type',
      type: 'ActivityType',
    },
    {
      name: 'sportType',
      baseName: 'sport_type',
      type: 'SportType',
    },
    {
      name: 'workoutType',
      baseName: 'workout_type',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return ClubActivity.attributeTypeMap;
  }
}

export class ClubAthlete {
  /**
   * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
   */
  'resourceState'?: number;
  /**
   * The athlete's first name.
   */
  'firstname'?: string;
  /**
   * The athlete's last initial.
   */
  'lastname'?: string;
  /**
   * The athlete's member status.
   */
  'member'?: string;
  /**
   * Whether the athlete is a club admin.
   */
  'admin'?: boolean;
  /**
   * Whether the athlete is club owner.
   */
  'owner'?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'resourceState',
      baseName: 'resource_state',
      type: 'number',
    },
    {
      name: 'firstname',
      baseName: 'firstname',
      type: 'string',
    },
    {
      name: 'lastname',
      baseName: 'lastname',
      type: 'string',
    },
    {
      name: 'member',
      baseName: 'member',
      type: 'string',
    },
    {
      name: 'admin',
      baseName: 'admin',
      type: 'boolean',
    },
    {
      name: 'owner',
      baseName: 'owner',
      type: 'boolean',
    },
  ];

  static getAttributeTypeMap() {
    return ClubAthlete.attributeTypeMap;
  }
}

export class Comment {
  /**
   * The unique identifier of this comment
   */
  'id'?: number;
  /**
   * The identifier of the activity this comment is related to
   */
  'activityId'?: number;
  /**
   * The content of the comment
   */
  'text'?: string;
  'athlete'?: SummaryAthlete;
  /**
   * The time at which this comment was created.
   */
  'createdAt'?: Date;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'number',
    },
    {
      name: 'activityId',
      baseName: 'activity_id',
      type: 'number',
    },
    {
      name: 'text',
      baseName: 'text',
      type: 'string',
    },
    {
      name: 'athlete',
      baseName: 'athlete',
      type: 'SummaryAthlete',
    },
    {
      name: 'createdAt',
      baseName: 'created_at',
      type: 'Date',
    },
  ];

  static getAttributeTypeMap() {
    return Comment.attributeTypeMap;
  }
}

export class MetaActivity {
  /**
   * The unique identifier of the activity
   */
  'id'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return MetaActivity.attributeTypeMap;
  }
}

export class SummaryActivity extends MetaActivity {
  /**
   * The identifier provided at upload time
   */
  'externalId'?: string;
  /**
   * The identifier of the upload that resulted in this activity
   */
  'uploadId'?: number;
  'athlete'?: MetaAthlete;
  /**
   * The name of the activity
   */
  'name'?: string;
  /**
   * The activity's distance, in meters
   */
  'distance'?: number;
  /**
   * The activity's moving time, in seconds
   */
  'movingTime'?: number;
  /**
   * The activity's elapsed time, in seconds
   */
  'elapsedTime'?: number;
  /**
   * The activity's total elevation gain.
   */
  'totalElevationGain'?: number;
  /**
   * The activity's highest elevation, in meters
   */
  'elevHigh'?: number;
  /**
   * The activity's lowest elevation, in meters
   */
  'elevLow'?: number;
  /**
   * Deprecated. Prefer to use sport_type
   */
  'type'?: ActivityType;
  'sportType'?: SportType;
  /**
   * The time at which the activity was started.
   */
  'startDate'?: Date;
  /**
   * The time at which the activity was started in the local timezone.
   */
  'startDateLocal'?: Date;
  /**
   * The timezone of the activity
   */
  'timezone'?: string;
  'startLatlng'?: LatLng;
  'endLatlng'?: LatLng;
  /**
   * The number of achievements gained during this activity
   */
  'achievementCount'?: number;
  /**
   * The number of kudos given for this activity
   */
  'kudosCount'?: number;
  /**
   * The number of comments for this activity
   */
  'commentCount'?: number;
  /**
   * The number of athletes for taking part in a group activity
   */
  'athleteCount'?: number;
  /**
   * The number of Instagram photos for this activity
   */
  'photoCount'?: number;
  /**
   * The number of Instagram and Strava photos for this activity
   */
  'totalPhotoCount'?: number;
  'map'?: PolylineMap;
  /**
   * Whether this activity was recorded on a training machine
   */
  'trainer'?: boolean;
  /**
   * Whether this activity is a commute
   */
  'commute'?: boolean;
  /**
   * Whether this activity was created manually
   */
  'manual'?: boolean;
  /**
   * Whether this activity is private
   */
  '_private'?: boolean;
  /**
   * Whether this activity is flagged
   */
  'flagged'?: boolean;
  /**
   * The activity's workout type
   */
  'workoutType'?: number;
  /**
   * The unique identifier of the upload in string format
   */
  'uploadIdStr'?: string;
  /**
   * The activity's average speed, in meters per second
   */
  'averageSpeed'?: number;
  /**
   * The activity's max speed, in meters per second
   */
  'maxSpeed'?: number;
  /**
   * Whether the logged-in athlete has kudoed this activity
   */
  'hasKudoed'?: boolean;
  /**
   * Whether the activity is muted
   */
  'hideFromHome'?: boolean;
  /**
   * The id of the gear for the activity
   */
  'gearId'?: string;
  /**
   * The total work done in kilojoules during this activity. Rides only
   */
  'kilojoules'?: number;
  /**
   * Average power output in watts during this activity. Rides only
   */
  'averageWatts'?: number;
  /**
   * Whether the watts are from a power meter, false if estimated
   */
  'deviceWatts'?: boolean;
  /**
   * Rides with power meter data only
   */
  'maxWatts'?: number;
  /**
   * Similar to Normalized Power. Rides with power meter data only
   */
  'weightedAverageWatts'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'externalId',
      baseName: 'external_id',
      type: 'string',
    },
    {
      name: 'uploadId',
      baseName: 'upload_id',
      type: 'number',
    },
    {
      name: 'athlete',
      baseName: 'athlete',
      type: 'MetaAthlete',
    },
    {
      name: 'name',
      baseName: 'name',
      type: 'string',
    },
    {
      name: 'distance',
      baseName: 'distance',
      type: 'number',
    },
    {
      name: 'movingTime',
      baseName: 'moving_time',
      type: 'number',
    },
    {
      name: 'elapsedTime',
      baseName: 'elapsed_time',
      type: 'number',
    },
    {
      name: 'totalElevationGain',
      baseName: 'total_elevation_gain',
      type: 'number',
    },
    {
      name: 'elevHigh',
      baseName: 'elev_high',
      type: 'number',
    },
    {
      name: 'elevLow',
      baseName: 'elev_low',
      type: 'number',
    },
    {
      name: 'type',
      baseName: 'type',
      type: 'ActivityType',
    },
    {
      name: 'sportType',
      baseName: 'sport_type',
      type: 'SportType',
    },
    {
      name: 'startDate',
      baseName: 'start_date',
      type: 'Date',
    },
    {
      name: 'startDateLocal',
      baseName: 'start_date_local',
      type: 'Date',
    },
    {
      name: 'timezone',
      baseName: 'timezone',
      type: 'string',
    },
    {
      name: 'startLatlng',
      baseName: 'start_latlng',
      type: 'LatLng',
    },
    {
      name: 'endLatlng',
      baseName: 'end_latlng',
      type: 'LatLng',
    },
    {
      name: 'achievementCount',
      baseName: 'achievement_count',
      type: 'number',
    },
    {
      name: 'kudosCount',
      baseName: 'kudos_count',
      type: 'number',
    },
    {
      name: 'commentCount',
      baseName: 'comment_count',
      type: 'number',
    },
    {
      name: 'athleteCount',
      baseName: 'athlete_count',
      type: 'number',
    },
    {
      name: 'photoCount',
      baseName: 'photo_count',
      type: 'number',
    },
    {
      name: 'totalPhotoCount',
      baseName: 'total_photo_count',
      type: 'number',
    },
    {
      name: 'map',
      baseName: 'map',
      type: 'PolylineMap',
    },
    {
      name: 'trainer',
      baseName: 'trainer',
      type: 'boolean',
    },
    {
      name: 'commute',
      baseName: 'commute',
      type: 'boolean',
    },
    {
      name: 'manual',
      baseName: 'manual',
      type: 'boolean',
    },
    {
      name: '_private',
      baseName: 'private',
      type: 'boolean',
    },
    {
      name: 'flagged',
      baseName: 'flagged',
      type: 'boolean',
    },
    {
      name: 'workoutType',
      baseName: 'workout_type',
      type: 'number',
    },
    {
      name: 'uploadIdStr',
      baseName: 'upload_id_str',
      type: 'string',
    },
    {
      name: 'averageSpeed',
      baseName: 'average_speed',
      type: 'number',
    },
    {
      name: 'maxSpeed',
      baseName: 'max_speed',
      type: 'number',
    },
    {
      name: 'hasKudoed',
      baseName: 'has_kudoed',
      type: 'boolean',
    },
    {
      name: 'hideFromHome',
      baseName: 'hide_from_home',
      type: 'boolean',
    },
    {
      name: 'gearId',
      baseName: 'gear_id',
      type: 'string',
    },
    {
      name: 'kilojoules',
      baseName: 'kilojoules',
      type: 'number',
    },
    {
      name: 'averageWatts',
      baseName: 'average_watts',
      type: 'number',
    },
    {
      name: 'deviceWatts',
      baseName: 'device_watts',
      type: 'boolean',
    },
    {
      name: 'maxWatts',
      baseName: 'max_watts',
      type: 'number',
    },
    {
      name: 'weightedAverageWatts',
      baseName: 'weighted_average_watts',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(SummaryActivity.attributeTypeMap);
  }
}

export class SummaryGear {
  /**
   * The gear's unique identifier.
   */
  'id'?: string;
  /**
   * Resource state, indicates level of detail. Possible values: 2 -> \"summary\", 3 -> \"detail\"
   */
  'resourceState'?: number;
  /**
   * Whether this gear's is the owner's default one.
   */
  'primary'?: boolean;
  /**
   * The gear's name.
   */
  'name'?: string;
  /**
   * The distance logged with this gear.
   */
  'distance'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'string',
    },
    {
      name: 'resourceState',
      baseName: 'resource_state',
      type: 'number',
    },
    {
      name: 'primary',
      baseName: 'primary',
      type: 'boolean',
    },
    {
      name: 'name',
      baseName: 'name',
      type: 'string',
    },
    {
      name: 'distance',
      baseName: 'distance',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return SummaryGear.attributeTypeMap;
  }
}

export class DetailedActivity extends SummaryActivity {
  /**
   * The description of the activity
   */
  'description'?: string;
  'photos'?: PhotosSummary;
  'gear'?: SummaryGear;
  /**
   * The number of kilocalories consumed during this activity
   */
  'calories'?: number;
  'segmentEfforts'?: Array<DetailedSegmentEffort>;
  /**
   * The name of the device used to record the activity
   */
  'deviceName'?: string;
  /**
   * The token used to embed a Strava activity
   */
  'embedToken'?: string;
  /**
   * The splits of this activity in metric units (for runs)
   */
  'splitsMetric'?: Array<Split>;
  /**
   * The splits of this activity in imperial units (for runs)
   */
  'splitsStandard'?: Array<Split>;
  'laps'?: Array<Lap>;
  'bestEfforts'?: Array<DetailedSegmentEffort>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'description',
      baseName: 'description',
      type: 'string',
    },
    {
      name: 'photos',
      baseName: 'photos',
      type: 'PhotosSummary',
    },
    {
      name: 'gear',
      baseName: 'gear',
      type: 'SummaryGear',
    },
    {
      name: 'calories',
      baseName: 'calories',
      type: 'number',
    },
    {
      name: 'segmentEfforts',
      baseName: 'segment_efforts',
      type: 'Array<DetailedSegmentEffort>',
    },
    {
      name: 'deviceName',
      baseName: 'device_name',
      type: 'string',
    },
    {
      name: 'embedToken',
      baseName: 'embed_token',
      type: 'string',
    },
    {
      name: 'splitsMetric',
      baseName: 'splits_metric',
      type: 'Array<Split>',
    },
    {
      name: 'splitsStandard',
      baseName: 'splits_standard',
      type: 'Array<Split>',
    },
    {
      name: 'laps',
      baseName: 'laps',
      type: 'Array<Lap>',
    },
    {
      name: 'bestEfforts',
      baseName: 'best_efforts',
      type: 'Array<DetailedSegmentEffort>',
    },
  ];

  static getAttributeTypeMap() {
    return super
      .getAttributeTypeMap()
      .concat(DetailedActivity.attributeTypeMap);
  }
}

export class SummaryAthlete extends MetaAthlete {
  /**
   * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
   */
  'resourceState'?: number;
  /**
   * The athlete's first name.
   */
  'firstname'?: string;
  /**
   * The athlete's last name.
   */
  'lastname'?: string;
  /**
   * URL to a 62x62 pixel profile picture.
   */
  'profileMedium'?: string;
  /**
   * URL to a 124x124 pixel profile picture.
   */
  'profile'?: string;
  /**
   * The athlete's city.
   */
  'city'?: string;
  /**
   * The athlete's state or geographical region.
   */
  'state'?: string;
  /**
   * The athlete's country.
   */
  'country'?: string;
  /**
   * The athlete's sex.
   */
  'sex'?: SummaryAthlete.SexEnum;
  /**
   * Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
   */
  'premium'?: boolean;
  /**
   * Whether the athlete has any Summit subscription.
   */
  'summit'?: boolean;
  /**
   * The time at which the athlete was created.
   */
  'createdAt'?: Date;
  /**
   * The time at which the athlete was last updated.
   */
  'updatedAt'?: Date;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'resourceState',
      baseName: 'resource_state',
      type: 'number',
    },
    {
      name: 'firstname',
      baseName: 'firstname',
      type: 'string',
    },
    {
      name: 'lastname',
      baseName: 'lastname',
      type: 'string',
    },
    {
      name: 'profileMedium',
      baseName: 'profile_medium',
      type: 'string',
    },
    {
      name: 'profile',
      baseName: 'profile',
      type: 'string',
    },
    {
      name: 'city',
      baseName: 'city',
      type: 'string',
    },
    {
      name: 'state',
      baseName: 'state',
      type: 'string',
    },
    {
      name: 'country',
      baseName: 'country',
      type: 'string',
    },
    {
      name: 'sex',
      baseName: 'sex',
      type: 'SummaryAthlete.SexEnum',
    },
    {
      name: 'premium',
      baseName: 'premium',
      type: 'boolean',
    },
    {
      name: 'summit',
      baseName: 'summit',
      type: 'boolean',
    },
    {
      name: 'createdAt',
      baseName: 'created_at',
      type: 'Date',
    },
    {
      name: 'updatedAt',
      baseName: 'updated_at',
      type: 'Date',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(SummaryAthlete.attributeTypeMap);
  }
}

export namespace SummaryAthlete {
  export enum SexEnum {
    M = <any>'M',
    F = <any>'F',
  }
}

export class MetaClub {
  /**
   * The club's unique identifier.
   */
  'id'?: number;
  /**
   * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
   */
  'resourceState'?: number;
  /**
   * The club's name.
   */
  'name'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'number',
    },
    {
      name: 'resourceState',
      baseName: 'resource_state',
      type: 'number',
    },
    {
      name: 'name',
      baseName: 'name',
      type: 'string',
    },
  ];

  static getAttributeTypeMap() {
    return MetaClub.attributeTypeMap;
  }
}

export class SummaryClub extends MetaClub {
  /**
   * URL to a 60x60 pixel profile picture.
   */
  'profileMedium'?: string;
  /**
   * URL to a ~1185x580 pixel cover photo.
   */
  'coverPhoto'?: string;
  /**
   * URL to a ~360x176  pixel cover photo.
   */
  'coverPhotoSmall'?: string;
  /**
   * Deprecated. Prefer to use activity_types.
   */
  'sportType'?: SummaryClub.SportTypeEnum;
  /**
   * The activity types that count for a club. This takes precedence over sport_type.
   */
  'activityTypes'?: Array<ActivityType>;
  /**
   * The club's city.
   */
  'city'?: string;
  /**
   * The club's state or geographical region.
   */
  'state'?: string;
  /**
   * The club's country.
   */
  'country'?: string;
  /**
   * Whether the club is private.
   */
  '_private'?: boolean;
  /**
   * The club's member count.
   */
  'memberCount'?: number;
  /**
   * Whether the club is featured or not.
   */
  'featured'?: boolean;
  /**
   * Whether the club is verified or not.
   */
  'verified'?: boolean;
  /**
   * The club's vanity URL.
   */
  'url'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'profileMedium',
      baseName: 'profile_medium',
      type: 'string',
    },
    {
      name: 'coverPhoto',
      baseName: 'cover_photo',
      type: 'string',
    },
    {
      name: 'coverPhotoSmall',
      baseName: 'cover_photo_small',
      type: 'string',
    },
    {
      name: 'sportType',
      baseName: 'sport_type',
      type: 'SummaryClub.SportTypeEnum',
    },
    {
      name: 'activityTypes',
      baseName: 'activity_types',
      type: 'Array<ActivityType>',
    },
    {
      name: 'city',
      baseName: 'city',
      type: 'string',
    },
    {
      name: 'state',
      baseName: 'state',
      type: 'string',
    },
    {
      name: 'country',
      baseName: 'country',
      type: 'string',
    },
    {
      name: '_private',
      baseName: 'private',
      type: 'boolean',
    },
    {
      name: 'memberCount',
      baseName: 'member_count',
      type: 'number',
    },
    {
      name: 'featured',
      baseName: 'featured',
      type: 'boolean',
    },
    {
      name: 'verified',
      baseName: 'verified',
      type: 'boolean',
    },
    {
      name: 'url',
      baseName: 'url',
      type: 'string',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(SummaryClub.attributeTypeMap);
  }
}

export namespace SummaryClub {
  export enum SportTypeEnum {
    Cycling = <any>'cycling',
    Running = <any>'running',
    Triathlon = <any>'triathlon',
    Other = <any>'other',
  }
}

export class DetailedAthlete extends SummaryAthlete {
  /**
   * The athlete's follower count.
   */
  'followerCount'?: number;
  /**
   * The athlete's friend count.
   */
  'friendCount'?: number;
  /**
   * The athlete's preferred unit system.
   */
  'measurementPreference'?: DetailedAthlete.MeasurementPreferenceEnum;
  /**
   * The athlete's FTP (Functional Threshold Power).
   */
  'ftp'?: number;
  /**
   * The athlete's weight.
   */
  'weight'?: number;
  /**
   * The athlete's clubs.
   */
  'clubs'?: Array<SummaryClub>;
  /**
   * The athlete's bikes.
   */
  'bikes'?: Array<SummaryGear>;
  /**
   * The athlete's shoes.
   */
  'shoes'?: Array<SummaryGear>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'followerCount',
      baseName: 'follower_count',
      type: 'number',
    },
    {
      name: 'friendCount',
      baseName: 'friend_count',
      type: 'number',
    },
    {
      name: 'measurementPreference',
      baseName: 'measurement_preference',
      type: 'DetailedAthlete.MeasurementPreferenceEnum',
    },
    {
      name: 'ftp',
      baseName: 'ftp',
      type: 'number',
    },
    {
      name: 'weight',
      baseName: 'weight',
      type: 'number',
    },
    {
      name: 'clubs',
      baseName: 'clubs',
      type: 'Array<SummaryClub>',
    },
    {
      name: 'bikes',
      baseName: 'bikes',
      type: 'Array<SummaryGear>',
    },
    {
      name: 'shoes',
      baseName: 'shoes',
      type: 'Array<SummaryGear>',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(DetailedAthlete.attributeTypeMap);
  }
}

export namespace DetailedAthlete {
  export enum MeasurementPreferenceEnum {
    Feet = <any>'feet',
    Meters = <any>'meters',
  }
}
export class DetailedClub extends SummaryClub {
  /**
   * The membership status of the logged-in athlete.
   */
  'membership'?: DetailedClub.MembershipEnum;
  /**
   * Whether the currently logged-in athlete is an administrator of this club.
   */
  'admin'?: boolean;
  /**
   * Whether the currently logged-in athlete is the owner of this club.
   */
  'owner'?: boolean;
  /**
   * The number of athletes in the club that the logged-in athlete follows.
   */
  'followingCount'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'membership',
      baseName: 'membership',
      type: 'DetailedClub.MembershipEnum',
    },
    {
      name: 'admin',
      baseName: 'admin',
      type: 'boolean',
    },
    {
      name: 'owner',
      baseName: 'owner',
      type: 'boolean',
    },
    {
      name: 'followingCount',
      baseName: 'following_count',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(DetailedClub.attributeTypeMap);
  }
}

export namespace DetailedClub {
  export enum MembershipEnum {
    Member = <any>'member',
    Pending = <any>'pending',
  }
}
export class DetailedGear extends SummaryGear {
  /**
   * The gear's brand name.
   */
  'brandName'?: string;
  /**
   * The gear's model name.
   */
  'modelName'?: string;
  /**
   * The gear's frame type (bike only).
   */
  'frameType'?: number;
  /**
   * The gear's description.
   */
  'description'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'brandName',
      baseName: 'brand_name',
      type: 'string',
    },
    {
      name: 'modelName',
      baseName: 'model_name',
      type: 'string',
    },
    {
      name: 'frameType',
      baseName: 'frame_type',
      type: 'number',
    },
    {
      name: 'description',
      baseName: 'description',
      type: 'string',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(DetailedGear.attributeTypeMap);
  }
}

export class SummarySegmentEffort {
  /**
   * The unique identifier of this effort
   */
  'id'?: number;
  /**
   * The unique identifier of the activity related to this effort
   */
  'activityId'?: number;
  /**
   * The effort's elapsed time
   */
  'elapsedTime'?: number;
  /**
   * The time at which the effort was started.
   */
  'startDate'?: Date;
  /**
   * The time at which the effort was started in the local timezone.
   */
  'startDateLocal'?: Date;
  /**
   * The effort's distance in meters
   */
  'distance'?: number;
  /**
   * Whether this effort is the current best on the leaderboard
   */
  'isKom'?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'number',
    },
    {
      name: 'activityId',
      baseName: 'activity_id',
      type: 'number',
    },
    {
      name: 'elapsedTime',
      baseName: 'elapsed_time',
      type: 'number',
    },
    {
      name: 'startDate',
      baseName: 'start_date',
      type: 'Date',
    },
    {
      name: 'startDateLocal',
      baseName: 'start_date_local',
      type: 'Date',
    },
    {
      name: 'distance',
      baseName: 'distance',
      type: 'number',
    },
    {
      name: 'isKom',
      baseName: 'is_kom',
      type: 'boolean',
    },
  ];

  static getAttributeTypeMap() {
    return SummarySegmentEffort.attributeTypeMap;
  }
}

export namespace DetailedSegment {}
export class DetailedSegmentEffort extends SummarySegmentEffort {
  /**
   * The name of the segment on which this effort was performed
   */
  'name'?: string;
  'activity'?: MetaActivity;
  'athlete'?: MetaAthlete;
  /**
   * The effort's moving time
   */
  'movingTime'?: number;
  /**
   * The start index of this effort in its activity's stream
   */
  'startIndex'?: number;
  /**
   * The end index of this effort in its activity's stream
   */
  'endIndex'?: number;
  /**
   * The effort's average cadence
   */
  'averageCadence'?: number;
  /**
   * The average wattage of this effort
   */
  'averageWatts'?: number;
  /**
   * For riding efforts, whether the wattage was reported by a dedicated recording device
   */
  'deviceWatts'?: boolean;
  /**
   * The heart heart rate of the athlete during this effort
   */
  'averageHeartrate'?: number;
  /**
   * The maximum heart rate of the athlete during this effort
   */
  'maxHeartrate'?: number;
  'segment'?: SummarySegment;
  /**
   * The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
   */
  'komRank'?: number;
  /**
   * The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
   */
  'prRank'?: number;
  /**
   * Whether this effort should be hidden when viewed within an activity
   */
  'hidden'?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'name',
      baseName: 'name',
      type: 'string',
    },
    {
      name: 'activity',
      baseName: 'activity',
      type: 'MetaActivity',
    },
    {
      name: 'athlete',
      baseName: 'athlete',
      type: 'MetaAthlete',
    },
    {
      name: 'movingTime',
      baseName: 'moving_time',
      type: 'number',
    },
    {
      name: 'startIndex',
      baseName: 'start_index',
      type: 'number',
    },
    {
      name: 'endIndex',
      baseName: 'end_index',
      type: 'number',
    },
    {
      name: 'averageCadence',
      baseName: 'average_cadence',
      type: 'number',
    },
    {
      name: 'averageWatts',
      baseName: 'average_watts',
      type: 'number',
    },
    {
      name: 'deviceWatts',
      baseName: 'device_watts',
      type: 'boolean',
    },
    {
      name: 'averageHeartrate',
      baseName: 'average_heartrate',
      type: 'number',
    },
    {
      name: 'maxHeartrate',
      baseName: 'max_heartrate',
      type: 'number',
    },
    {
      name: 'segment',
      baseName: 'segment',
      type: 'SummarySegment',
    },
    {
      name: 'komRank',
      baseName: 'kom_rank',
      type: 'number',
    },
    {
      name: 'prRank',
      baseName: 'pr_rank',
      type: 'number',
    },
    {
      name: 'hidden',
      baseName: 'hidden',
      type: 'boolean',
    },
  ];

  static getAttributeTypeMap() {
    return super
      .getAttributeTypeMap()
      .concat(DetailedSegmentEffort.attributeTypeMap);
  }
}

export class DistanceStream extends BaseStream {
  /**
   * The sequence of distance values for this stream, in meters
   */
  'data'?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'data',
      baseName: 'data',
      type: 'Array<number>',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(DistanceStream.attributeTypeMap);
  }
}

export namespace DistanceStream {}
export class ExplorerResponse {
  /**
   * The set of segments matching an explorer request
   */
  'segments'?: Array<ExplorerSegment>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'segments',
      baseName: 'segments',
      type: 'Array<ExplorerSegment>',
    },
  ];

  static getAttributeTypeMap() {
    return ExplorerResponse.attributeTypeMap;
  }
}

export class ExplorerSegment {
  /**
   * The unique identifier of this segment
   */
  'id'?: number;
  /**
   * The name of this segment
   */
  'name'?: string;
  /**
   * The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catégorie, 0 is uncategorized in climb_category. If climb_category = 5, climb_category_desc = HC. If climb_category = 2, climb_category_desc = 3.
   */
  'climbCategory'?: number;
  /**
   * The description for the category of the climb
   */
  'climbCategoryDesc'?: ExplorerSegment.ClimbCategoryDescEnum;
  /**
   * The segment's average grade, in percents
   */
  'avgGrade'?: number;
  'startLatlng'?: LatLng;
  'endLatlng'?: LatLng;
  /**
   * The segments's evelation difference, in meters
   */
  'elevDifference'?: number;
  /**
   * The segment's distance, in meters
   */
  'distance'?: number;
  /**
   * The polyline of the segment
   */
  'points'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'number',
    },
    {
      name: 'name',
      baseName: 'name',
      type: 'string',
    },
    {
      name: 'climbCategory',
      baseName: 'climb_category',
      type: 'number',
    },
    {
      name: 'climbCategoryDesc',
      baseName: 'climb_category_desc',
      type: 'ExplorerSegment.ClimbCategoryDescEnum',
    },
    {
      name: 'avgGrade',
      baseName: 'avg_grade',
      type: 'number',
    },
    {
      name: 'startLatlng',
      baseName: 'start_latlng',
      type: 'LatLng',
    },
    {
      name: 'endLatlng',
      baseName: 'end_latlng',
      type: 'LatLng',
    },
    {
      name: 'elevDifference',
      baseName: 'elev_difference',
      type: 'number',
    },
    {
      name: 'distance',
      baseName: 'distance',
      type: 'number',
    },
    {
      name: 'points',
      baseName: 'points',
      type: 'string',
    },
  ];

  static getAttributeTypeMap() {
    return ExplorerSegment.attributeTypeMap;
  }
}

export namespace ExplorerSegment {
  export enum ClimbCategoryDescEnum {
    NC = <any>'NC',
    _4 = <any>'4',
    _3 = <any>'3',
    _2 = <any>'2',
    _1 = <any>'1',
    HC = <any>'HC',
  }
}
/**
 * Encapsulates the errors that may be returned from the API.
 */
export class Fault {
  /**
   * The set of specific errors associated with this fault, if any.
   */
  'errors'?: Array<Error>;
  /**
   * The message of the fault.
   */
  'message'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'errors',
      baseName: 'errors',
      type: 'Array<Error>',
    },
    {
      name: 'message',
      baseName: 'message',
      type: 'string',
    },
  ];

  static getAttributeTypeMap() {
    return Fault.attributeTypeMap;
  }
}

export class ZoneRange {
  /**
   * The minimum value in the range.
   */
  'min'?: number;
  /**
   * The maximum value in the range.
   */
  'max'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'min',
      baseName: 'min',
      type: 'number',
    },
    {
      name: 'max',
      baseName: 'max',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return ZoneRange.attributeTypeMap;
  }
}

export class ZoneRanges extends Array<ZoneRange> {
  static discriminator: string | undefined = undefined;
}

export class HeartRateZoneRanges {
  /**
   * Whether the athlete has set their own custom heart rate zones
   */
  'customZones'?: boolean;
  'zones'?: ZoneRanges;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'customZones',
      baseName: 'custom_zones',
      type: 'boolean',
    },
    {
      name: 'zones',
      baseName: 'zones',
      type: 'ZoneRanges',
    },
  ];

  static getAttributeTypeMap() {
    return HeartRateZoneRanges.attributeTypeMap;
  }
}

export class HeartrateStream extends BaseStream {
  /**
   * The sequence of heart rate values for this stream, in beats per minute
   */
  'data'?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'data',
      baseName: 'data',
      type: 'Array<number>',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(HeartrateStream.attributeTypeMap);
  }
}

export namespace HeartrateStream {}
export class Lap {
  /**
   * The unique identifier of this lap
   */
  'id'?: number;
  'activity'?: MetaActivity;
  'athlete'?: MetaAthlete;
  /**
   * The lap's average cadence
   */
  'averageCadence'?: number;
  /**
   * The lap's average speed
   */
  'averageSpeed'?: number;
  /**
   * The lap's distance, in meters
   */
  'distance'?: number;
  /**
   * The lap's elapsed time, in seconds
   */
  'elapsedTime'?: number;
  /**
   * The start index of this effort in its activity's stream
   */
  'startIndex'?: number;
  /**
   * The end index of this effort in its activity's stream
   */
  'endIndex'?: number;
  /**
   * The index of this lap in the activity it belongs to
   */
  'lapIndex'?: number;
  /**
   * The maximum speed of this lat, in meters per second
   */
  'maxSpeed'?: number;
  /**
   * The lap's moving time, in seconds
   */
  'movingTime'?: number;
  /**
   * The name of the lap
   */
  'name'?: string;
  /**
   * The athlete's pace zone during this lap
   */
  'paceZone'?: number;
  'split'?: number;
  /**
   * The time at which the lap was started.
   */
  'startDate'?: Date;
  /**
   * The time at which the lap was started in the local timezone.
   */
  'startDateLocal'?: Date;
  /**
   * The elevation gain of this lap, in meters
   */
  'totalElevationGain'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'number',
    },
    {
      name: 'activity',
      baseName: 'activity',
      type: 'MetaActivity',
    },
    {
      name: 'athlete',
      baseName: 'athlete',
      type: 'MetaAthlete',
    },
    {
      name: 'averageCadence',
      baseName: 'average_cadence',
      type: 'number',
    },
    {
      name: 'averageSpeed',
      baseName: 'average_speed',
      type: 'number',
    },
    {
      name: 'distance',
      baseName: 'distance',
      type: 'number',
    },
    {
      name: 'elapsedTime',
      baseName: 'elapsed_time',
      type: 'number',
    },
    {
      name: 'startIndex',
      baseName: 'start_index',
      type: 'number',
    },
    {
      name: 'endIndex',
      baseName: 'end_index',
      type: 'number',
    },
    {
      name: 'lapIndex',
      baseName: 'lap_index',
      type: 'number',
    },
    {
      name: 'maxSpeed',
      baseName: 'max_speed',
      type: 'number',
    },
    {
      name: 'movingTime',
      baseName: 'moving_time',
      type: 'number',
    },
    {
      name: 'name',
      baseName: 'name',
      type: 'string',
    },
    {
      name: 'paceZone',
      baseName: 'pace_zone',
      type: 'number',
    },
    {
      name: 'split',
      baseName: 'split',
      type: 'number',
    },
    {
      name: 'startDate',
      baseName: 'start_date',
      type: 'Date',
    },
    {
      name: 'startDateLocal',
      baseName: 'start_date_local',
      type: 'Date',
    },
    {
      name: 'totalElevationGain',
      baseName: 'total_elevation_gain',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return Lap.attributeTypeMap;
  }
}

/**
 * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
 */
export class LatLng extends Array<number> {
  static discriminator: string | undefined = undefined;
}

export class LatLngStream extends BaseStream {
  /**
   * The sequence of lat/long values for this stream
   */
  'data'?: Array<LatLng>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'data',
      baseName: 'data',
      type: 'Array<LatLng>',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(LatLngStream.attributeTypeMap);
  }
}

export namespace LatLngStream {}

/**
 * Renamed from 'Error' to 'ModelError' to avoid a name conflict with built-in Error in JavaScript
 */
export class ModelError {
  /**
   * The code associated with this error.
   */
  'code'?: string;
  /**
   * The specific field or aspect of the resource associated with this error.
   */
  'field'?: string;
  /**
   * The type of resource associated with this error.
   */
  'resource'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'code',
      baseName: 'code',
      type: 'string',
    },
    {
      name: 'field',
      baseName: 'field',
      type: 'string',
    },
    {
      name: 'resource',
      baseName: 'resource',
      type: 'string',
    },
  ];

  static getAttributeTypeMap() {
    return ModelError.attributeTypeMap;
  }
}

export class MovingStream extends BaseStream {
  /**
   * The sequence of moving values for this stream, as boolean values
   */
  'data'?: Array<boolean>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'data',
      baseName: 'data',
      type: 'Array<boolean>',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(MovingStream.attributeTypeMap);
  }
}

export namespace MovingStream {}
export class PhotosSummary {
  /**
   * The number of photos
   */
  'count'?: number;
  'primary'?: PhotosSummaryPrimary;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'count',
      baseName: 'count',
      type: 'number',
    },
    {
      name: 'primary',
      baseName: 'primary',
      type: 'PhotosSummaryPrimary',
    },
  ];

  static getAttributeTypeMap() {
    return PhotosSummary.attributeTypeMap;
  }
}

export class PhotosSummaryPrimary {
  'id'?: number;
  'source'?: number;
  'uniqueId'?: string;
  'urls'?: { [key: string]: string };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'number',
    },
    {
      name: 'source',
      baseName: 'source',
      type: 'number',
    },
    {
      name: 'uniqueId',
      baseName: 'unique_id',
      type: 'string',
    },
    {
      name: 'urls',
      baseName: 'urls',
      type: '{ [key: string]: string; }',
    },
  ];

  static getAttributeTypeMap() {
    return PhotosSummaryPrimary.attributeTypeMap;
  }
}

export class PolylineMap {
  /**
   * The identifier of the map
   */
  'id'?: string;
  /**
   * The polyline of the map, only returned on detailed representation of an object
   */
  'polyline'?: string;
  /**
   * The summary polyline of the map
   */
  'summaryPolyline'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'string',
    },
    {
      name: 'polyline',
      baseName: 'polyline',
      type: 'string',
    },
    {
      name: 'summaryPolyline',
      baseName: 'summary_polyline',
      type: 'string',
    },
  ];

  static getAttributeTypeMap() {
    return PolylineMap.attributeTypeMap;
  }
}

export class PowerStream extends BaseStream {
  /**
   * The sequence of power values for this stream, in watts
   */
  'data'?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'data',
      baseName: 'data',
      type: 'Array<number>',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(PowerStream.attributeTypeMap);
  }
}

export namespace PowerStream {}
export class PowerZoneRanges {
  'zones'?: ZoneRanges;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'zones',
      baseName: 'zones',
      type: 'ZoneRanges',
    },
  ];

  static getAttributeTypeMap() {
    return PowerZoneRanges.attributeTypeMap;
  }
}

export class Route {
  'athlete'?: SummaryAthlete;
  /**
   * The description of the route
   */
  'description'?: string;
  /**
   * The route's distance, in meters
   */
  'distance'?: number;
  /**
   * The route's elevation gain.
   */
  'elevationGain'?: number;
  /**
   * The unique identifier of this route
   */
  'id'?: number;
  /**
   * The unique identifier of the route in string format
   */
  'idStr'?: string;
  'map'?: PolylineMap;
  /**
   * The name of this route
   */
  'name'?: string;
  /**
   * Whether this route is private
   */
  '_private'?: boolean;
  /**
   * Whether this route is starred by the logged-in athlete
   */
  'starred'?: boolean;
  /**
   * An epoch timestamp of when the route was created
   */
  'timestamp'?: number;
  /**
   * This route's type (1 for ride, 2 for runs)
   */
  'type'?: number;
  /**
   * This route's sub-type (1 for road, 2 for mountain bike, 3 for cross, 4 for trail, 5 for mixed)
   */
  'subType'?: number;
  /**
   * The time at which the route was created
   */
  'createdAt'?: Date;
  /**
   * The time at which the route was last updated
   */
  'updatedAt'?: Date;
  /**
   * Estimated time in seconds for the authenticated athlete to complete route
   */
  'estimatedMovingTime'?: number;
  /**
   * The segments traversed by this route
   */
  'segments'?: Array<SummarySegment>;
  /**
   * The custom waypoints along this route
   */
  'waypoints'?: Array<Waypoint>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'athlete',
      baseName: 'athlete',
      type: 'SummaryAthlete',
    },
    {
      name: 'description',
      baseName: 'description',
      type: 'string',
    },
    {
      name: 'distance',
      baseName: 'distance',
      type: 'number',
    },
    {
      name: 'elevationGain',
      baseName: 'elevation_gain',
      type: 'number',
    },
    {
      name: 'id',
      baseName: 'id',
      type: 'number',
    },
    {
      name: 'idStr',
      baseName: 'id_str',
      type: 'string',
    },
    {
      name: 'map',
      baseName: 'map',
      type: 'PolylineMap',
    },
    {
      name: 'name',
      baseName: 'name',
      type: 'string',
    },
    {
      name: '_private',
      baseName: 'private',
      type: 'boolean',
    },
    {
      name: 'starred',
      baseName: 'starred',
      type: 'boolean',
    },
    {
      name: 'timestamp',
      baseName: 'timestamp',
      type: 'number',
    },
    {
      name: 'type',
      baseName: 'type',
      type: 'number',
    },
    {
      name: 'subType',
      baseName: 'sub_type',
      type: 'number',
    },
    {
      name: 'createdAt',
      baseName: 'created_at',
      type: 'Date',
    },
    {
      name: 'updatedAt',
      baseName: 'updated_at',
      type: 'Date',
    },
    {
      name: 'estimatedMovingTime',
      baseName: 'estimated_moving_time',
      type: 'number',
    },
    {
      name: 'segments',
      baseName: 'segments',
      type: 'Array<SummarySegment>',
    },
    {
      name: 'waypoints',
      baseName: 'waypoints',
      type: 'Array<Waypoint>',
    },
  ];

  static getAttributeTypeMap() {
    return Route.attributeTypeMap;
  }
}

export class SmoothGradeStream extends BaseStream {
  /**
   * The sequence of grade values for this stream, as percents of a grade
   */
  'data'?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'data',
      baseName: 'data',
      type: 'Array<number>',
    },
  ];

  static getAttributeTypeMap() {
    return super
      .getAttributeTypeMap()
      .concat(SmoothGradeStream.attributeTypeMap);
  }
}

export namespace SmoothGradeStream {}
export class SmoothVelocityStream extends BaseStream {
  /**
   * The sequence of velocity values for this stream, in meters per second
   */
  'data'?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'data',
      baseName: 'data',
      type: 'Array<number>',
    },
  ];

  static getAttributeTypeMap() {
    return super
      .getAttributeTypeMap()
      .concat(SmoothVelocityStream.attributeTypeMap);
  }
}

export namespace SmoothVelocityStream {}
export class Split {
  /**
   * The average speed of this split, in meters per second
   */
  'averageSpeed'?: number;
  /**
   * The distance of this split, in meters
   */
  'distance'?: number;
  /**
   * The elapsed time of this split, in seconds
   */
  'elapsedTime'?: number;
  /**
   * The elevation difference of this split, in meters
   */
  'elevationDifference'?: number;
  /**
   * The pacing zone of this split
   */
  'paceZone'?: number;
  /**
   * The moving time of this split, in seconds
   */
  'movingTime'?: number;
  /**
   * N/A
   */
  'split'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'averageSpeed',
      baseName: 'average_speed',
      type: 'number',
    },
    {
      name: 'distance',
      baseName: 'distance',
      type: 'number',
    },
    {
      name: 'elapsedTime',
      baseName: 'elapsed_time',
      type: 'number',
    },
    {
      name: 'elevationDifference',
      baseName: 'elevation_difference',
      type: 'number',
    },
    {
      name: 'paceZone',
      baseName: 'pace_zone',
      type: 'number',
    },
    {
      name: 'movingTime',
      baseName: 'moving_time',
      type: 'number',
    },
    {
      name: 'split',
      baseName: 'split',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return Split.attributeTypeMap;
  }
}

/**
 * An enumeration of the sport types an activity may have. Distinct from ActivityType in that it has new types (e.g. MountainBikeRide)
 */
export class SportType {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return SportType.attributeTypeMap;
  }
}

export class StreamSet {
  'time'?: TimeStream;
  'distance'?: DistanceStream;
  'latlng'?: LatLngStream;
  'altitude'?: AltitudeStream;
  'velocitySmooth'?: SmoothVelocityStream;
  'heartrate'?: HeartrateStream;
  'cadence'?: CadenceStream;
  'watts'?: PowerStream;
  'temp'?: TemperatureStream;
  'moving'?: MovingStream;
  'gradeSmooth'?: SmoothGradeStream;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'time',
      baseName: 'time',
      type: 'TimeStream',
    },
    {
      name: 'distance',
      baseName: 'distance',
      type: 'DistanceStream',
    },
    {
      name: 'latlng',
      baseName: 'latlng',
      type: 'LatLngStream',
    },
    {
      name: 'altitude',
      baseName: 'altitude',
      type: 'AltitudeStream',
    },
    {
      name: 'velocitySmooth',
      baseName: 'velocity_smooth',
      type: 'SmoothVelocityStream',
    },
    {
      name: 'heartrate',
      baseName: 'heartrate',
      type: 'HeartrateStream',
    },
    {
      name: 'cadence',
      baseName: 'cadence',
      type: 'CadenceStream',
    },
    {
      name: 'watts',
      baseName: 'watts',
      type: 'PowerStream',
    },
    {
      name: 'temp',
      baseName: 'temp',
      type: 'TemperatureStream',
    },
    {
      name: 'moving',
      baseName: 'moving',
      type: 'MovingStream',
    },
    {
      name: 'gradeSmooth',
      baseName: 'grade_smooth',
      type: 'SmoothGradeStream',
    },
  ];

  static getAttributeTypeMap() {
    return StreamSet.attributeTypeMap;
  }
}

export class SummaryPRSegmentEffort {
  /**
   * The unique identifier of the activity related to the PR effort.
   */
  'prActivityId'?: number;
  /**
   * The elapsed time ot the PR effort.
   */
  'prElapsedTime'?: number;
  /**
   * The time at which the PR effort was started.
   */
  'prDate'?: Date;
  /**
   * Number of efforts by the authenticated athlete on this segment.
   */
  'effortCount'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'prActivityId',
      baseName: 'pr_activity_id',
      type: 'number',
    },
    {
      name: 'prElapsedTime',
      baseName: 'pr_elapsed_time',
      type: 'number',
    },
    {
      name: 'prDate',
      baseName: 'pr_date',
      type: 'Date',
    },
    {
      name: 'effortCount',
      baseName: 'effort_count',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return SummaryPRSegmentEffort.attributeTypeMap;
  }
}

export class SummarySegment {
  /**
   * The unique identifier of this segment
   */
  'id'?: number;
  /**
   * The name of this segment
   */
  'name'?: string;
  'activityType'?: SummarySegment.ActivityTypeEnum;
  /**
   * The segment's distance, in meters
   */
  'distance'?: number;
  /**
   * The segment's average grade, in percents
   */
  'averageGrade'?: number;
  /**
   * The segments's maximum grade, in percents
   */
  'maximumGrade'?: number;
  /**
   * The segments's highest elevation, in meters
   */
  'elevationHigh'?: number;
  /**
   * The segments's lowest elevation, in meters
   */
  'elevationLow'?: number;
  'startLatlng'?: LatLng;
  'endLatlng'?: LatLng;
  /**
   * The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catégorie, 0 is uncategorized in climb_category.
   */
  'climbCategory'?: number;
  /**
   * The segments's city.
   */
  'city'?: string;
  /**
   * The segments's state or geographical region.
   */
  'state'?: string;
  /**
   * The segment's country.
   */
  'country'?: string;
  /**
   * Whether this segment is private.
   */
  '_private'?: boolean;
  'athletePrEffort'?: SummaryPRSegmentEffort;
  'athleteSegmentStats'?: SummarySegmentEffort;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'number',
    },
    {
      name: 'name',
      baseName: 'name',
      type: 'string',
    },
    {
      name: 'activityType',
      baseName: 'activity_type',
      type: 'SummarySegment.ActivityTypeEnum',
    },
    {
      name: 'distance',
      baseName: 'distance',
      type: 'number',
    },
    {
      name: 'averageGrade',
      baseName: 'average_grade',
      type: 'number',
    },
    {
      name: 'maximumGrade',
      baseName: 'maximum_grade',
      type: 'number',
    },
    {
      name: 'elevationHigh',
      baseName: 'elevation_high',
      type: 'number',
    },
    {
      name: 'elevationLow',
      baseName: 'elevation_low',
      type: 'number',
    },
    {
      name: 'startLatlng',
      baseName: 'start_latlng',
      type: 'LatLng',
    },
    {
      name: 'endLatlng',
      baseName: 'end_latlng',
      type: 'LatLng',
    },
    {
      name: 'climbCategory',
      baseName: 'climb_category',
      type: 'number',
    },
    {
      name: 'city',
      baseName: 'city',
      type: 'string',
    },
    {
      name: 'state',
      baseName: 'state',
      type: 'string',
    },
    {
      name: 'country',
      baseName: 'country',
      type: 'string',
    },
    {
      name: '_private',
      baseName: 'private',
      type: 'boolean',
    },
    {
      name: 'athletePrEffort',
      baseName: 'athlete_pr_effort',
      type: 'SummaryPRSegmentEffort',
    },
    {
      name: 'athleteSegmentStats',
      baseName: 'athlete_segment_stats',
      type: 'SummarySegmentEffort',
    },
  ];

  static getAttributeTypeMap() {
    return SummarySegment.attributeTypeMap;
  }
}

export namespace SummarySegment {
  export enum ActivityTypeEnum {
    Ride = <any>'Ride',
    Run = <any>'Run',
  }
}

export class DetailedSegment extends SummarySegment {
  /**
   * The time at which the segment was created.
   */
  'createdAt'?: Date;
  /**
   * The time at which the segment was last updated.
   */
  'updatedAt'?: Date;
  /**
   * The segment's total elevation gain.
   */
  'totalElevationGain'?: number;
  'map'?: PolylineMap;
  /**
   * The total number of efforts for this segment
   */
  'effortCount'?: number;
  /**
   * The number of unique athletes who have an effort for this segment
   */
  'athleteCount'?: number;
  /**
   * Whether this segment is considered hazardous
   */
  'hazardous'?: boolean;
  /**
   * The number of stars for this segment
   */
  'starCount'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'createdAt',
      baseName: 'created_at',
      type: 'Date',
    },
    {
      name: 'updatedAt',
      baseName: 'updated_at',
      type: 'Date',
    },
    {
      name: 'totalElevationGain',
      baseName: 'total_elevation_gain',
      type: 'number',
    },
    {
      name: 'map',
      baseName: 'map',
      type: 'PolylineMap',
    },
    {
      name: 'effortCount',
      baseName: 'effort_count',
      type: 'number',
    },
    {
      name: 'athleteCount',
      baseName: 'athlete_count',
      type: 'number',
    },
    {
      name: 'hazardous',
      baseName: 'hazardous',
      type: 'boolean',
    },
    {
      name: 'starCount',
      baseName: 'star_count',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(DetailedSegment.attributeTypeMap);
  }
}

export class TemperatureStream extends BaseStream {
  /**
   * The sequence of temperature values for this stream, in celsius degrees
   */
  'data'?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'data',
      baseName: 'data',
      type: 'Array<number>',
    },
  ];

  static getAttributeTypeMap() {
    return super
      .getAttributeTypeMap()
      .concat(TemperatureStream.attributeTypeMap);
  }
}

export namespace TemperatureStream {}
export class TimeStream extends BaseStream {
  /**
   * The sequence of time values for this stream, in seconds
   */
  'data'?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'data',
      baseName: 'data',
      type: 'Array<number>',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(TimeStream.attributeTypeMap);
  }
}

export namespace TimeStream {}
/**
 * Stores the exclusive ranges representing zones and the time spent in each.
 */
export class TimedZoneDistribution extends Array<TimedZoneRange> {
  static discriminator: string | undefined = undefined;
}

/**
 * A union type representing the time spent in a given zone.
 */
export class TimedZoneRange extends ZoneRange {
  /**
   * The number of seconds spent in this zone
   */
  'time'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'time',
      baseName: 'time',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(TimedZoneRange.attributeTypeMap);
  }
}

export class UpdatableActivity {
  /**
   * Whether this activity is a commute
   */
  'commute'?: boolean;
  /**
   * Whether this activity was recorded on a training machine
   */
  'trainer'?: boolean;
  /**
   * Whether this activity is muted
   */
  'hideFromHome'?: boolean;
  /**
   * The description of the activity
   */
  'description'?: string;
  /**
   * The name of the activity
   */
  'name'?: string;
  /**
   * Deprecated. Prefer to use sport_type. In a request where both type and sport_type are present, this field will be ignored
   */
  'type'?: ActivityType;
  'sportType'?: SportType;
  /**
   * Identifier for the gear associated with the activity. ‘none’ clears gear from activity
   */
  'gearId'?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'commute',
      baseName: 'commute',
      type: 'boolean',
    },
    {
      name: 'trainer',
      baseName: 'trainer',
      type: 'boolean',
    },
    {
      name: 'hideFromHome',
      baseName: 'hide_from_home',
      type: 'boolean',
    },
    {
      name: 'description',
      baseName: 'description',
      type: 'string',
    },
    {
      name: 'name',
      baseName: 'name',
      type: 'string',
    },
    {
      name: 'type',
      baseName: 'type',
      type: 'ActivityType',
    },
    {
      name: 'sportType',
      baseName: 'sport_type',
      type: 'SportType',
    },
    {
      name: 'gearId',
      baseName: 'gear_id',
      type: 'string',
    },
  ];

  static getAttributeTypeMap() {
    return UpdatableActivity.attributeTypeMap;
  }
}

export class Upload {
  /**
   * The unique identifier of the upload
   */
  'id'?: number;
  /**
   * The unique identifier of the upload in string format
   */
  'idStr'?: string;
  /**
   * The external identifier of the upload
   */
  'externalId'?: string;
  /**
   * The error associated with this upload
   */
  'error'?: string;
  /**
   * The status of this upload
   */
  'status'?: string;
  /**
   * The identifier of the activity this upload resulted into
   */
  'activityId'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'id',
      baseName: 'id',
      type: 'number',
    },
    {
      name: 'idStr',
      baseName: 'id_str',
      type: 'string',
    },
    {
      name: 'externalId',
      baseName: 'external_id',
      type: 'string',
    },
    {
      name: 'error',
      baseName: 'error',
      type: 'string',
    },
    {
      name: 'status',
      baseName: 'status',
      type: 'string',
    },
    {
      name: 'activityId',
      baseName: 'activity_id',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return Upload.attributeTypeMap;
  }
}

export class Waypoint {
  /**
   * The location along the route that the waypoint is closest to
   */
  'latlng'?: LatLng;
  /**
   * A location off of the route that the waypoint is (optional)
   */
  'targetLatlng'?: LatLng;
  /**
   * Categories that the waypoint belongs to
   */
  'categories'?: Array<string>;
  /**
   * A title for the waypoint
   */
  'title'?: string;
  /**
   * A description of the waypoint (optional)
   */
  'description'?: string;
  /**
   * The number meters along the route that the waypoint is located
   */
  'distanceIntoRoute'?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'latlng',
      baseName: 'latlng',
      type: 'LatLng',
    },
    {
      name: 'targetLatlng',
      baseName: 'target_latlng',
      type: 'LatLng',
    },
    {
      name: 'categories',
      baseName: 'categories',
      type: 'Array<string>',
    },
    {
      name: 'title',
      baseName: 'title',
      type: 'string',
    },
    {
      name: 'description',
      baseName: 'description',
      type: 'string',
    },
    {
      name: 'distanceIntoRoute',
      baseName: 'distance_into_route',
      type: 'number',
    },
  ];

  static getAttributeTypeMap() {
    return Waypoint.attributeTypeMap;
  }
}

export class Zones {
  'heartRate'?: HeartRateZoneRanges;
  'power'?: PowerZoneRanges;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: 'heartRate',
      baseName: 'heart_rate',
      type: 'HeartRateZoneRanges',
    },
    {
      name: 'power',
      baseName: 'power',
      type: 'PowerZoneRanges',
    },
  ];

  static getAttributeTypeMap() {
    return Zones.attributeTypeMap;
  }
}

let enumsMap: { [index: string]: any } = {
  'ActivityZone.TypeEnum': ActivityZone.TypeEnum,
  'BaseStream.ResolutionEnum': BaseStream.ResolutionEnum,
  'BaseStream.SeriesTypeEnum': BaseStream.SeriesTypeEnum,
  'DetailedAthlete.MeasurementPreferenceEnum':
    DetailedAthlete.MeasurementPreferenceEnum,
  'DetailedClub.MembershipEnum': DetailedClub.MembershipEnum,
  'ExplorerSegment.ClimbCategoryDescEnum':
    ExplorerSegment.ClimbCategoryDescEnum,
  'SummaryAthlete.SexEnum': SummaryAthlete.SexEnum,
  'SummaryClub.SportTypeEnum': SummaryClub.SportTypeEnum,
  'SummarySegment.ActivityTypeEnum': SummarySegment.ActivityTypeEnum,
};

let typeMap: { [index: string]: any } = {
  ActivityStats: ActivityStats,
  ActivityTotal: ActivityTotal,
  ActivityType: ActivityType,
  ActivityZone: ActivityZone,
  AltitudeStream: AltitudeStream,
  BaseStream: BaseStream,
  CadenceStream: CadenceStream,
  ClubActivity: ClubActivity,
  ClubAthlete: ClubAthlete,
  Comment: Comment,
  DetailedActivity: DetailedActivity,
  DetailedAthlete: DetailedAthlete,
  DetailedClub: DetailedClub,
  DetailedGear: DetailedGear,
  DetailedSegment: DetailedSegment,
  DetailedSegmentEffort: DetailedSegmentEffort,
  DistanceStream: DistanceStream,
  ExplorerResponse: ExplorerResponse,
  ExplorerSegment: ExplorerSegment,
  Fault: Fault,
  HeartRateZoneRanges: HeartRateZoneRanges,
  HeartrateStream: HeartrateStream,
  Lap: Lap,
  LatLng: LatLng,
  LatLngStream: LatLngStream,
  MetaActivity: MetaActivity,
  MetaAthlete: MetaAthlete,
  MetaClub: MetaClub,
  ModelError: ModelError,
  MovingStream: MovingStream,
  PhotosSummary: PhotosSummary,
  PhotosSummaryPrimary: PhotosSummaryPrimary,
  PolylineMap: PolylineMap,
  PowerStream: PowerStream,
  PowerZoneRanges: PowerZoneRanges,
  Route: Route,
  SmoothGradeStream: SmoothGradeStream,
  SmoothVelocityStream: SmoothVelocityStream,
  Split: Split,
  SportType: SportType,
  StreamSet: StreamSet,
  SummaryActivity: SummaryActivity,
  SummaryAthlete: SummaryAthlete,
  SummaryClub: SummaryClub,
  SummaryGear: SummaryGear,
  SummaryPRSegmentEffort: SummaryPRSegmentEffort,
  SummarySegment: SummarySegment,
  SummarySegmentEffort: SummarySegmentEffort,
  TemperatureStream: TemperatureStream,
  TimeStream: TimeStream,
  TimedZoneDistribution: TimedZoneDistribution,
  TimedZoneRange: TimedZoneRange,
  UpdatableActivity: UpdatableActivity,
  Upload: Upload,
  Waypoint: Waypoint,
  ZoneRange: ZoneRange,
  ZoneRanges: ZoneRanges,
  Zones: Zones,
};

export interface Authentication {
  /**
   * Apply authentication settings to header and query params.
   */
  applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
  public username: string = '';
  public password: string = '';

  applyToRequest(requestOptions: localVarRequest.Options): void {
    requestOptions.auth = {
      username: this.username,
      password: this.password,
    };
  }
}

export class ApiKeyAuth implements Authentication {
  public apiKey: string = '';

  constructor(
    private location: string,
    private paramName: string,
  ) {}

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (this.location == 'query') {
      (<any>requestOptions.qs)[this.paramName] = this.apiKey;
    } else if (
      this.location == 'header' &&
      requestOptions &&
      requestOptions.headers
    ) {
      requestOptions.headers[this.paramName] = this.apiKey;
    }
  }
}

export class OAuth implements Authentication {
  public accessToken: string = '';

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers['Authorization'] = 'Bearer ' + this.accessToken;
    }
  }
}

export class VoidAuth implements Authentication {
  public username: string = '';
  public password: string = '';

  applyToRequest(_: localVarRequest.Options): void {
    // Do nothing
  }
}

export enum ActivitiesApiApiKeys {}

export class ActivitiesApi {
  protected _basePath = DEFAULT_BASE_PATH;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    strava_oauth: new OAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string,
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ActivitiesApiApiKeys, value: string) {
    (this.authentications as any)[ActivitiesApiApiKeys[key]].apiKey = value;
  }

  set accessToken(token: string) {
    this.authentications.strava_oauth.accessToken = token;
  }
  /**
   * Creates a manual activity for an athlete, requires activity:write scope.
   * @summary Create an Activity
   * @param name The name of the activity.
   * @param sportType Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
   * @param startDateLocal ISO 8601 formatted date time.
   * @param elapsedTime In seconds.
   * @param type Type of activity. For example - Run, Ride etc.
   * @param description Description of the activity.
   * @param distance In meters.
   * @param trainer Set to 1 to mark as a trainer activity.
   * @param commute Set to 1 to mark as commute.
   * @param {*} [options] Override http request options.
   */
  public createActivity(
    name: string,
    sportType: string,
    startDateLocal: Date,
    elapsedTime: number,
    type?: string,
    description?: string,
    distance?: number,
    trainer?: number,
    commute?: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: DetailedActivity }> {
    const localVarPath = this.basePath + '/activities';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'name' is not null or undefined
    if (name === null || name === undefined) {
      throw new Error(
        'Required parameter name was null or undefined when calling createActivity.',
      );
    }

    // verify required parameter 'sportType' is not null or undefined
    if (sportType === null || sportType === undefined) {
      throw new Error(
        'Required parameter sportType was null or undefined when calling createActivity.',
      );
    }

    // verify required parameter 'startDateLocal' is not null or undefined
    if (startDateLocal === null || startDateLocal === undefined) {
      throw new Error(
        'Required parameter startDateLocal was null or undefined when calling createActivity.',
      );
    }

    // verify required parameter 'elapsedTime' is not null or undefined
    if (elapsedTime === null || elapsedTime === undefined) {
      throw new Error(
        'Required parameter elapsedTime was null or undefined when calling createActivity.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    if (name !== undefined) {
      localVarFormParams['name'] = ObjectSerializer.serialize(name, 'string');
    }

    if (type !== undefined) {
      localVarFormParams['type'] = ObjectSerializer.serialize(type, 'string');
    }

    if (sportType !== undefined) {
      localVarFormParams['sport_type'] = ObjectSerializer.serialize(
        sportType,
        'string',
      );
    }

    if (startDateLocal !== undefined) {
      localVarFormParams['start_date_local'] = ObjectSerializer.serialize(
        startDateLocal,
        'Date',
      );
    }

    if (elapsedTime !== undefined) {
      localVarFormParams['elapsed_time'] = ObjectSerializer.serialize(
        elapsedTime,
        'number',
      );
    }

    if (description !== undefined) {
      localVarFormParams['description'] = ObjectSerializer.serialize(
        description,
        'string',
      );
    }

    if (distance !== undefined) {
      localVarFormParams['distance'] = ObjectSerializer.serialize(
        distance,
        'number',
      );
    }

    if (trainer !== undefined) {
      localVarFormParams['trainer'] = ObjectSerializer.serialize(
        trainer,
        'number',
      );
    }

    if (commute !== undefined) {
      localVarFormParams['commute'] = ObjectSerializer.serialize(
        commute,
        'number',
      );
    }

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: DetailedActivity;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'DetailedActivity');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
   * @summary Get Activity
   * @param id The identifier of the activity.
   * @param includeAllEfforts To include all segments efforts.
   * @param {*} [options] Override http request options.
   */
  public getActivityById(
    id: number,
    includeAllEfforts?: boolean,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: DetailedActivity }> {
    const localVarPath =
      this.basePath +
      '/activities/{id}'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getActivityById.',
      );
    }

    if (includeAllEfforts !== undefined) {
      localVarQueryParameters['include_all_efforts'] =
        ObjectSerializer.serialize(includeAllEfforts, 'boolean');
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: DetailedActivity;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'DetailedActivity');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
   * @summary List Activity Comments
   * @param id The identifier of the activity.
   * @param page Deprecated. Prefer to use after_cursor.
   * @param perPage Deprecated. Prefer to use page_size.
   * @param pageSize Number of items per page. Defaults to 30.
   * @param afterCursor Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
   * @param {*} [options] Override http request options.
   */
  public getCommentsByActivityId(
    id: number,
    page?: number,
    perPage?: number,
    pageSize?: number,
    afterCursor?: string,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Array<Comment> }> {
    const localVarPath =
      this.basePath +
      '/activities/{id}/comments'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getCommentsByActivityId.',
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number',
      );
    }

    if (perPage !== undefined) {
      localVarQueryParameters['per_page'] = ObjectSerializer.serialize(
        perPage,
        'number',
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters['page_size'] = ObjectSerializer.serialize(
        pageSize,
        'number',
      );
    }

    if (afterCursor !== undefined) {
      localVarQueryParameters['after_cursor'] = ObjectSerializer.serialize(
        afterCursor,
        'string',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: Array<Comment>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'Array<Comment>');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
   * @summary List Activity Kudoers
   * @param id The identifier of the activity.
   * @param page Page number. Defaults to 1.
   * @param perPage Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request options.
   */
  public getKudoersByActivityId(
    id: number,
    page?: number,
    perPage?: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Array<SummaryAthlete> }> {
    const localVarPath =
      this.basePath +
      '/activities/{id}/kudos'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getKudoersByActivityId.',
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number',
      );
    }

    if (perPage !== undefined) {
      localVarQueryParameters['per_page'] = ObjectSerializer.serialize(
        perPage,
        'number',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: Array<SummaryAthlete>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'Array<SummaryAthlete>');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
   * @summary List Activity Laps
   * @param id The identifier of the activity.
   * @param {*} [options] Override http request options.
   */
  public getLapsByActivityId(
    id: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Array<Lap> }> {
    const localVarPath =
      this.basePath +
      '/activities/{id}/laps'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getLapsByActivityId.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Array<Lap> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'Array<Lap>');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
  /**
   * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
   * @summary List Athlete Activities
   * @param before An epoch timestamp to use for filtering activities that have taken place before a certain time.
   * @param after An epoch timestamp to use for filtering activities that have taken place after a certain time.
   * @param page Page number. Defaults to 1.
   * @param perPage Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request options.
   */
  public getLoggedInAthleteActivities(
    before?: number,
    after?: number,
    page?: number,
    perPage?: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Array<SummaryActivity> }> {
    const localVarPath = this.basePath + '/athlete/activities';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    if (before !== undefined) {
      localVarQueryParameters['before'] = ObjectSerializer.serialize(
        before,
        'number',
      );
    }

    if (after !== undefined) {
      localVarQueryParameters['after'] = ObjectSerializer.serialize(
        after,
        'number',
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number',
      );
    }

    if (perPage !== undefined) {
      localVarQueryParameters['per_page'] = ObjectSerializer.serialize(
        perPage,
        'number',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: Array<SummaryActivity>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'Array<SummaryActivity>');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
   * @summary Get Activity Zones
   * @param id The identifier of the activity.
   * @param {*} [options] Override http request options.
   */
  public getZonesByActivityId(
    id: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Array<ActivityZone> }> {
    const localVarPath =
      this.basePath +
      '/activities/{id}/zones'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getZonesByActivityId.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: Array<ActivityZone>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'Array<ActivityZone>');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
   * @summary Update Activity
   * @param id The identifier of the activity.
   * @param body
   * @param {*} [options] Override http request options.
   */
  public updateActivityById(
    id: number,
    body?: UpdatableActivity,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: DetailedActivity }> {
    const localVarPath =
      this.basePath +
      '/activities/{id}'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling updateActivityById.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, 'UpdatableActivity'),
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: DetailedActivity;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'DetailedActivity');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum AthletesApiApiKeys {}

export class AthletesApi {
  protected _basePath = DEFAULT_BASE_PATH;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    strava_oauth: new OAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string,
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: AthletesApiApiKeys, value: string) {
    (this.authentications as any)[AthletesApiApiKeys[key]].apiKey = value;
  }

  set accessToken(token: string) {
    this.authentications.strava_oauth.accessToken = token;
  }
  /**
   * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
   * @summary Get Authenticated Athlete
   * @param {*} [options] Override http request options.
   */
  public getLoggedInAthlete(
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: DetailedAthlete }> {
    const localVarPath = this.basePath + '/athlete';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: DetailedAthlete;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'DetailedAthlete');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns the the authenticated athlete's heart rate and power zones. Requires profile:read_all.
   * @summary Get Zones
   * @param {*} [options] Override http request options.
   */
  public getLoggedInAthleteZones(
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Zones }> {
    const localVarPath = this.basePath + '/athlete/zones';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Zones }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'Zones');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
  /**
   * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
   * @summary Get Athlete Stats
   * @param id The identifier of the athlete. Must match the authenticated athlete.
   * @param {*} [options] Override http request options.
   */
  public getStats(
    id: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: ActivityStats }> {
    const localVarPath =
      this.basePath +
      '/athletes/{id}/stats'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getStats.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: ActivityStats }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'ActivityStats');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
  /**
   * Update the currently authenticated athlete. Requires profile:write scope.
   * @summary Update Athlete
   * @param weight The weight of the athlete in kilograms.
   * @param {*} [options] Override http request options.
   */
  public updateLoggedInAthlete(
    weight: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: DetailedAthlete }> {
    const localVarPath =
      this.basePath +
      '/athlete'.replace(
        '{' + 'weight' + '}',
        encodeURIComponent(String(weight)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'weight' is not null or undefined
    if (weight === null || weight === undefined) {
      throw new Error(
        'Required parameter weight was null or undefined when calling updateLoggedInAthlete.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: DetailedAthlete;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'DetailedAthlete');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum ClubsApiApiKeys {}

export class ClubsApi {
  protected _basePath = DEFAULT_BASE_PATH;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    strava_oauth: new OAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string,
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ClubsApiApiKeys, value: string) {
    (this.authentications as any)[ClubsApiApiKeys[key]].apiKey = value;
  }

  set accessToken(token: string) {
    this.authentications.strava_oauth.accessToken = token;
  }
  /**
   * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
   * @summary List Club Activities
   * @param id The identifier of the club.
   * @param page Page number. Defaults to 1.
   * @param perPage Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request options.
   */
  public getClubActivitiesById(
    id: number,
    page?: number,
    perPage?: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Array<ClubActivity> }> {
    const localVarPath =
      this.basePath +
      '/clubs/{id}/activities'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getClubActivitiesById.',
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number',
      );
    }

    if (perPage !== undefined) {
      localVarQueryParameters['per_page'] = ObjectSerializer.serialize(
        perPage,
        'number',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: Array<ClubActivity>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'Array<ClubActivity>');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns a list of the administrators of a given club.
   * @summary List Club Administrators
   * @param id The identifier of the club.
   * @param page Page number. Defaults to 1.
   * @param perPage Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request options.
   */
  public getClubAdminsById(
    id: number,
    page?: number,
    perPage?: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Array<SummaryAthlete> }> {
    const localVarPath =
      this.basePath +
      '/clubs/{id}/admins'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getClubAdminsById.',
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number',
      );
    }

    if (perPage !== undefined) {
      localVarQueryParameters['per_page'] = ObjectSerializer.serialize(
        perPage,
        'number',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: Array<SummaryAthlete>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'Array<SummaryAthlete>');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns a given a club using its identifier.
   * @summary Get Club
   * @param id The identifier of the club.
   * @param {*} [options] Override http request options.
   */
  public getClubById(
    id: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: DetailedClub }> {
    const localVarPath =
      this.basePath +
      '/clubs/{id}'.replace('{' + 'id' + '}', encodeURIComponent(String(id)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getClubById.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: DetailedClub }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'DetailedClub');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
  /**
   * Returns a list of the athletes who are members of a given club.
   * @summary List Club Members
   * @param id The identifier of the club.
   * @param page Page number. Defaults to 1.
   * @param perPage Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request options.
   */
  public getClubMembersById(
    id: number,
    page?: number,
    perPage?: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Array<ClubAthlete> }> {
    const localVarPath =
      this.basePath +
      '/clubs/{id}/members'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getClubMembersById.',
      );
    }

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number',
      );
    }

    if (perPage !== undefined) {
      localVarQueryParameters['per_page'] = ObjectSerializer.serialize(
        perPage,
        'number',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: Array<ClubAthlete>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'Array<ClubAthlete>');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns a list of the clubs whose membership includes the authenticated athlete.
   * @summary List Athlete Clubs
   * @param page Page number. Defaults to 1.
   * @param perPage Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request options.
   */
  public getLoggedInAthleteClubs(
    page?: number,
    perPage?: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Array<SummaryClub> }> {
    const localVarPath = this.basePath + '/athlete/clubs';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number',
      );
    }

    if (perPage !== undefined) {
      localVarQueryParameters['per_page'] = ObjectSerializer.serialize(
        perPage,
        'number',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: Array<SummaryClub>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'Array<SummaryClub>');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum GearsApiApiKeys {}

export class GearsApi {
  protected _basePath = DEFAULT_BASE_PATH;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    strava_oauth: new OAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string,
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: GearsApiApiKeys, value: string) {
    (this.authentications as any)[GearsApiApiKeys[key]].apiKey = value;
  }

  set accessToken(token: string) {
    this.authentications.strava_oauth.accessToken = token;
  }
  /**
   * Returns an equipment using its identifier.
   * @summary Get Equipment
   * @param id The identifier of the gear.
   * @param {*} [options] Override http request options.
   */
  public getGearById(
    id: string,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: DetailedGear }> {
    const localVarPath =
      this.basePath +
      '/gear/{id}'.replace('{' + 'id' + '}', encodeURIComponent(String(id)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getGearById.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: DetailedGear }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'DetailedGear');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
}
export enum RoutesApiApiKeys {}

export class RoutesApi {
  protected _basePath = DEFAULT_BASE_PATH;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    strava_oauth: new OAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string,
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: RoutesApiApiKeys, value: string) {
    (this.authentications as any)[RoutesApiApiKeys[key]].apiKey = value;
  }

  set accessToken(token: string) {
    this.authentications.strava_oauth.accessToken = token;
  }
  /**
   * Returns a GPX file of the route. Requires read_all scope for private routes.
   * @summary Export Route GPX
   * @param id The identifier of the route.
   * @param {*} [options] Override http request options.
   */
  public getRouteAsGPX(
    id: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      '/routes/{id}/export_gpx'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getRouteAsGPX.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
  /**
   * Returns a TCX file of the route. Requires read_all scope for private routes.
   * @summary Export Route TCX
   * @param id The identifier of the route.
   * @param {*} [options] Override http request options.
   */
  public getRouteAsTCX(
    id: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      '/routes/{id}/export_tcx'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getRouteAsTCX.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
  /**
   * Returns a route using its identifier. Requires read_all scope for private routes.
   * @summary Get Route
   * @param id The identifier of the route.
   * @param {*} [options] Override http request options.
   */
  public getRouteById(
    id: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Route }> {
    const localVarPath =
      this.basePath +
      '/routes/{id}'.replace('{' + 'id' + '}', encodeURIComponent(String(id)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getRouteById.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Route }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'Route');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
  /**
   * Returns a list of the routes created by the authenticated athlete. Private routes are filtered out unless requested by a token with read_all scope.
   * @summary List Athlete Routes
   * @param page Page number. Defaults to 1.
   * @param perPage Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request options.
   */
  public getRoutesByAthleteId(
    page?: number,
    perPage?: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Array<Route> }> {
    const localVarPath = this.basePath + '/athletes/{id}/routes';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number',
      );
    }

    if (perPage !== undefined) {
      localVarQueryParameters['per_page'] = ObjectSerializer.serialize(
        perPage,
        'number',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Array<Route> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'Array<Route>');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
}
export enum SegmentEffortsApiApiKeys {}

export class SegmentEffortsApi {
  protected _basePath = DEFAULT_BASE_PATH;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    strava_oauth: new OAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string,
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: SegmentEffortsApiApiKeys, value: string) {
    (this.authentications as any)[SegmentEffortsApiApiKeys[key]].apiKey = value;
  }

  set accessToken(token: string) {
    this.authentications.strava_oauth.accessToken = token;
  }
  /**
   * Returns a set of the authenticated athlete's segment efforts for a given segment.  Requires subscription.
   * @summary List Segment Efforts
   * @param segmentId The identifier of the segment.
   * @param startDateLocal ISO 8601 formatted date time.
   * @param endDateLocal ISO 8601 formatted date time.
   * @param perPage Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request options.
   */
  public getEffortsBySegmentId(
    segmentId: number,
    startDateLocal?: Date,
    endDateLocal?: Date,
    perPage?: number,
    options: any = {},
  ): Promise<{
    response: http.IncomingMessage;
    body: Array<DetailedSegmentEffort>;
  }> {
    const localVarPath = this.basePath + '/segment_efforts';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'segmentId' is not null or undefined
    if (segmentId === null || segmentId === undefined) {
      throw new Error(
        'Required parameter segmentId was null or undefined when calling getEffortsBySegmentId.',
      );
    }

    if (segmentId !== undefined) {
      localVarQueryParameters['segment_id'] = ObjectSerializer.serialize(
        segmentId,
        'number',
      );
    }

    if (startDateLocal !== undefined) {
      localVarQueryParameters['start_date_local'] = ObjectSerializer.serialize(
        startDateLocal,
        'Date',
      );
    }

    if (endDateLocal !== undefined) {
      localVarQueryParameters['end_date_local'] = ObjectSerializer.serialize(
        endDateLocal,
        'Date',
      );
    }

    if (perPage !== undefined) {
      localVarQueryParameters['per_page'] = ObjectSerializer.serialize(
        perPage,
        'number',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: Array<DetailedSegmentEffort>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            'Array<DetailedSegmentEffort>',
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
   * @summary Get Segment Effort
   * @param id The identifier of the segment effort.
   * @param {*} [options] Override http request options.
   */
  public getSegmentEffortById(
    id: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: DetailedSegmentEffort }> {
    const localVarPath =
      this.basePath +
      '/segment_efforts/{id}'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getSegmentEffortById.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: DetailedSegmentEffort;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'DetailedSegmentEffort');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum SegmentsApiApiKeys {}

export class SegmentsApi {
  protected _basePath = DEFAULT_BASE_PATH;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    strava_oauth: new OAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string,
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: SegmentsApiApiKeys, value: string) {
    (this.authentications as any)[SegmentsApiApiKeys[key]].apiKey = value;
  }

  set accessToken(token: string) {
    this.authentications.strava_oauth.accessToken = token;
  }
  /**
   * Returns the top 10 segments matching a specified query.
   * @summary Explore segments
   * @param bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
   * @param activityType Desired activity type.
   * @param minCat The minimum climbing category.
   * @param maxCat The maximum climbing category.
   * @param {*} [options] Override http request options.
   */
  public exploreSegments(
    bounds: Array<number>,
    activityType?: 'running' | 'riding',
    minCat?: number,
    maxCat?: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: ExplorerResponse }> {
    const localVarPath = this.basePath + '/segments/explore';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'bounds' is not null or undefined
    if (bounds === null || bounds === undefined) {
      throw new Error(
        'Required parameter bounds was null or undefined when calling exploreSegments.',
      );
    }

    if (bounds !== undefined) {
      localVarQueryParameters['bounds'] = ObjectSerializer.serialize(
        bounds,
        'Array<number>',
      );
    }

    if (activityType !== undefined) {
      localVarQueryParameters['activity_type'] = ObjectSerializer.serialize(
        activityType,
        "'running' | 'riding'",
      );
    }

    if (minCat !== undefined) {
      localVarQueryParameters['min_cat'] = ObjectSerializer.serialize(
        minCat,
        'number',
      );
    }

    if (maxCat !== undefined) {
      localVarQueryParameters['max_cat'] = ObjectSerializer.serialize(
        maxCat,
        'number',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: ExplorerResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'ExplorerResponse');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * List of the authenticated athlete's starred segments. Private segments are filtered out unless requested by a token with read_all scope.
   * @summary List Starred Segments
   * @param page Page number. Defaults to 1.
   * @param perPage Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request options.
   */
  public getLoggedInAthleteStarredSegments(
    page?: number,
    perPage?: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Array<SummarySegment> }> {
    const localVarPath = this.basePath + '/segments/starred';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    if (page !== undefined) {
      localVarQueryParameters['page'] = ObjectSerializer.serialize(
        page,
        'number',
      );
    }

    if (perPage !== undefined) {
      localVarQueryParameters['per_page'] = ObjectSerializer.serialize(
        perPage,
        'number',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: Array<SummarySegment>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'Array<SummarySegment>');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
   * @summary Get Segment
   * @param id The identifier of the segment.
   * @param {*} [options] Override http request options.
   */
  public getSegmentById(
    id: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: DetailedSegment }> {
    const localVarPath =
      this.basePath +
      '/segments/{id}'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getSegmentById.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: DetailedSegment;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'DetailedSegment');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
   * @summary Star Segment
   * @param id The identifier of the segment to star.
   * @param starred If true, star the segment; if false, unstar the segment.
   * @param {*} [options] Override http request options.
   */
  public starSegment(
    id: number,
    starred: boolean,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: DetailedSegment }> {
    const localVarPath =
      this.basePath +
      '/segments/{id}/starred'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling starSegment.',
      );
    }

    // verify required parameter 'starred' is not null or undefined
    if (starred === null || starred === undefined) {
      throw new Error(
        'Required parameter starred was null or undefined when calling starSegment.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    if (starred !== undefined) {
      localVarFormParams['starred'] = ObjectSerializer.serialize(
        starred,
        'boolean',
      );
    }

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'PUT',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: DetailedSegment;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, 'DetailedSegment');
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum StreamsApiApiKeys {}

export class StreamsApi {
  protected _basePath = DEFAULT_BASE_PATH;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    strava_oauth: new OAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string,
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: StreamsApiApiKeys, value: string) {
    (this.authentications as any)[StreamsApiApiKeys[key]].apiKey = value;
  }

  set accessToken(token: string) {
    this.authentications.strava_oauth.accessToken = token;
  }
  /**
   * Returns the given activity's streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
   * @summary Get Activity Streams
   * @param id The identifier of the activity.
   * @param keys Desired stream types.
   * @param keyByType Must be true.
   * @param {*} [options] Override http request options.
   */
  public getActivityStreams(
    id: number,
    keys: Array<
      | 'time'
      | 'distance'
      | 'latlng'
      | 'altitude'
      | 'velocity_smooth'
      | 'heartrate'
      | 'cadence'
      | 'watts'
      | 'temp'
      | 'moving'
      | 'grade_smooth'
    >,
    keyByType: boolean,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: StreamSet }> {
    const localVarPath =
      this.basePath +
      '/activities/{id}/streams'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getActivityStreams.',
      );
    }

    // verify required parameter 'keys' is not null or undefined
    if (keys === null || keys === undefined) {
      throw new Error(
        'Required parameter keys was null or undefined when calling getActivityStreams.',
      );
    }

    // verify required parameter 'keyByType' is not null or undefined
    if (keyByType === null || keyByType === undefined) {
      throw new Error(
        'Required parameter keyByType was null or undefined when calling getActivityStreams.',
      );
    }

    if (keys !== undefined) {
      localVarQueryParameters['keys'] = ObjectSerializer.serialize(
        keys,
        "Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>",
      );
    }

    if (keyByType !== undefined) {
      localVarQueryParameters['key_by_type'] = ObjectSerializer.serialize(
        keyByType,
        'boolean',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: StreamSet }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'StreamSet');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
  /**
   * Returns the given route's streams. Requires read_all scope for private routes.
   * @summary Get Route Streams
   * @param id The identifier of the route.
   * @param {*} [options] Override http request options.
   */
  public getRouteStreams(
    id: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: StreamSet }> {
    const localVarPath =
      this.basePath +
      '/routes/{id}/streams'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getRouteStreams.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: StreamSet }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'StreamSet');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
  /**
   * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
   * @summary Get Segment Effort Streams
   * @param id The identifier of the segment effort.
   * @param keys The types of streams to return.
   * @param keyByType Must be true.
   * @param {*} [options] Override http request options.
   */
  public getSegmentEffortStreams(
    id: number,
    keys: Array<
      | 'time'
      | 'distance'
      | 'latlng'
      | 'altitude'
      | 'velocity_smooth'
      | 'heartrate'
      | 'cadence'
      | 'watts'
      | 'temp'
      | 'moving'
      | 'grade_smooth'
    >,
    keyByType: boolean,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: StreamSet }> {
    const localVarPath =
      this.basePath +
      '/segment_efforts/{id}/streams'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getSegmentEffortStreams.',
      );
    }

    // verify required parameter 'keys' is not null or undefined
    if (keys === null || keys === undefined) {
      throw new Error(
        'Required parameter keys was null or undefined when calling getSegmentEffortStreams.',
      );
    }

    // verify required parameter 'keyByType' is not null or undefined
    if (keyByType === null || keyByType === undefined) {
      throw new Error(
        'Required parameter keyByType was null or undefined when calling getSegmentEffortStreams.',
      );
    }

    if (keys !== undefined) {
      localVarQueryParameters['keys'] = ObjectSerializer.serialize(
        keys,
        "Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>",
      );
    }

    if (keyByType !== undefined) {
      localVarQueryParameters['key_by_type'] = ObjectSerializer.serialize(
        keyByType,
        'boolean',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: StreamSet }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'StreamSet');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
  /**
   * Returns the given segment's streams. Requires read_all scope for private segments.
   * @summary Get Segment Streams
   * @param id The identifier of the segment.
   * @param keys The types of streams to return.
   * @param keyByType Must be true.
   * @param {*} [options] Override http request options.
   */
  public getSegmentStreams(
    id: number,
    keys: Array<'distance' | 'latlng' | 'altitude'>,
    keyByType: boolean,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: StreamSet }> {
    const localVarPath =
      this.basePath +
      '/segments/{id}/streams'.replace(
        '{' + 'id' + '}',
        encodeURIComponent(String(id)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getSegmentStreams.',
      );
    }

    // verify required parameter 'keys' is not null or undefined
    if (keys === null || keys === undefined) {
      throw new Error(
        'Required parameter keys was null or undefined when calling getSegmentStreams.',
      );
    }

    // verify required parameter 'keyByType' is not null or undefined
    if (keyByType === null || keyByType === undefined) {
      throw new Error(
        'Required parameter keyByType was null or undefined when calling getSegmentStreams.',
      );
    }

    if (keys !== undefined) {
      localVarQueryParameters['keys'] = ObjectSerializer.serialize(
        keys,
        "Array<'distance' | 'latlng' | 'altitude'>",
      );
    }

    if (keyByType !== undefined) {
      localVarQueryParameters['key_by_type'] = ObjectSerializer.serialize(
        keyByType,
        'boolean',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: StreamSet }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'StreamSet');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
}
export enum UploadsApiApiKeys {}

export class UploadsApi {
  protected _basePath = DEFAULT_BASE_PATH;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    strava_oauth: new OAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string,
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: UploadsApiApiKeys, value: string) {
    (this.authentications as any)[UploadsApiApiKeys[key]].apiKey = value;
  }

  set accessToken(token: string) {
    this.authentications.strava_oauth.accessToken = token;
  }
  /**
   * Uploads a new data file to create an activity from. Requires activity:write scope.
   * @summary Upload Activity
   * @param file The uploaded file.
   * @param name The desired name of the resulting activity.
   * @param description The desired description of the resulting activity.
   * @param trainer Whether the resulting activity should be marked as having been performed on a trainer.
   * @param commute Whether the resulting activity should be tagged as a commute.
   * @param dataType The format of the uploaded file.
   * @param externalId The desired external identifier of the resulting activity.
   * @param {*} [options] Override http request options.
   */
  public createUpload(
    file?: Buffer,
    name?: string,
    description?: string,
    trainer?: string,
    commute?: string,
    dataType?: 'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz',
    externalId?: string,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Upload }> {
    const localVarPath = this.basePath + '/uploads';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    if (file !== undefined) {
      localVarFormParams['file'] = file;
    }
    localVarUseFormData = true;

    if (name !== undefined) {
      localVarFormParams['name'] = ObjectSerializer.serialize(name, 'string');
    }

    if (description !== undefined) {
      localVarFormParams['description'] = ObjectSerializer.serialize(
        description,
        'string',
      );
    }

    if (trainer !== undefined) {
      localVarFormParams['trainer'] = ObjectSerializer.serialize(
        trainer,
        'string',
      );
    }

    if (commute !== undefined) {
      localVarFormParams['commute'] = ObjectSerializer.serialize(
        commute,
        'string',
      );
    }

    if (dataType !== undefined) {
      localVarFormParams['data_type'] = ObjectSerializer.serialize(
        dataType,
        "'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz'",
      );
    }

    if (externalId !== undefined) {
      localVarFormParams['external_id'] = ObjectSerializer.serialize(
        externalId,
        'string',
      );
    }

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Upload }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'Upload');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
  /**
   * Returns an upload for a given identifier. Requires activity:write scope.
   * @summary Get Upload
   * @param uploadId The identifier of the upload.
   * @param {*} [options] Override http request options.
   */
  public getUploadById(
    uploadId: number,
    options: any = {},
  ): Promise<{ response: http.IncomingMessage; body: Upload }> {
    const localVarPath =
      this.basePath +
      '/uploads/{uploadId}'.replace(
        '{' + 'uploadId' + '}',
        encodeURIComponent(String(uploadId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'uploadId' is not null or undefined
    if (uploadId === null || uploadId === undefined) {
      throw new Error(
        'Required parameter uploadId was null or undefined when calling getUploadById.',
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Upload }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, 'Upload');
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      },
    );
  }
}
